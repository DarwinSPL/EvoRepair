// automatically generated by Xtext
grammar de.evorepair.feature.expression.ExpressionDsl with de.evorepair.logic.EvoDsl

import "http://hyvar-project.eu/feature/expression/1.0" 
import "http://hyvar-project.eu/feature/1.0" as feature
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://hyvar-project.eu/feature/dataValues/1.0" as dataValues
import "http://hyvar-project.eu/feature/context/1.0" as context

EvoAbstractTerm:
	EvoOr;
	
EvoUnequalSize returns EvoAbstractTerm:
	EvoUnequal | EvoSize;


EvoImplicationSize returns EvoAbstractTerm:
	EvoImplication | EvoSize;


EvoImplication returns EvoAbstractTerm:
	EvoBiconditional({EvoImplication.leftElement=current} ('=>') rightElement=EvoBiconditionalSize)*;
	
	
EvoBiconditionalSize returns EvoAbstractTerm:
	EvoBiconditional | EvoSize;
		
		
EvoBiconditional returns EvoAbstractTerm:
	EvoSetInclusion({EvoBiconditional.leftElement=current} ('<=>') rightElement=EvoSetInclusionSize)*;
	
	
EvoSetInclusionSize returns EvoAbstractTerm:
	EvoSetInclusion | EvoSize;


EvoSetInclusion returns EvoAbstractTerm:
	EvoSetIntersection({EvoSetInclusion.leftElement=current} ('inclusion') rightElement=EvoSetIntersection)*;
	

EvoSetIntersection returns EvoAbstractTerm:
	EvoSetUnion({EvoSetIntersection.leftElement=current} ('intersection') rightElement=EvoSetUnion)*;


EvoSetUnion returns EvoAbstractTerm:
	EvoSetDifference({EvoSetUnion.leftElement=current} ('union') rightElement=EvoSetDifference)*;


EvoSetDifference returns EvoAbstractTerm:
	EvoSetSymmetricDifference({EvoSetDifference.leftElement=current} ('difference') rightElement=EvoSetSymmetricDifference)*;


EvoSetSymmetricDifference returns EvoAbstractTerm:
	EvoSetCartesianProduct({EvoSetSymmetricDifference.leftElement=current} ('symmetric_difference') rightElement=EvoSetCartesianProduct)*;


EvoSetCartesianProduct returns EvoAbstractTerm:
	EvoElementOf({EvoSetCartesianProduct.leftElement=current} ('x') rightElement=EvoElementOf)*;


EvoSetCardinality returns EvoAbstractTerm:
	{EvoSetCardinality} (('|' element=EvoAbstractTerm '|') | ('size' '(' element=EvoAbstractTerm ')'));


EvoElementOf returns EvoAbstractTerm:
	EvoTerminal({EvoSetElementOf.leftElement=current} ('elementOf') rightElement=EvoTerminal)*;


EvoFeatureVariable returns evovar::EvoFeatureVariable: 
	'feature' name=ID;
	
	
EvoForAll:
	'forAll' '('
		boundedVariables += EvoFeatureVariable (',' boundedVariables += EvoFeatureVariable) ':'
		element=EvoAbstractTerm
	')';
	
	
EvoExists:
	'exists' '('
		boundedVariables+=EvoFeatureVariable ':'
		element=EvoAbstractTerm
	')';


EvoNot:
	'not' '(' element=EvoAbstractTerm ')';


EvoSatisfiable returns EvoAbstractTerm: 
	({EvoSatisfiable}'satisfiable' '(' variables+=(EvoSetVariable | EvoApplicationConstraintTerm) (',' variables+=(EvoSetVariable | EvoApplicationConstraintTerm))* ')');


EvoTerminal returns EvoAbstractTerm:
	EvoVariableTerm | 
	EvoSetTerm | 
	EvoApplicationConstraintTerm | 
	EvoForAll |
	EvoExists |
	EvoNot |
	EvoFeatureType | 
	EvoGroupType | 
	EvoSetCardinality |
	EvoChildrenOf |
	EvoParentOf |
	EvoSiblingsOf |
	EvoSatisfiable |
	'(' EvoXOr ')';

/* 
EvoSize returns EvoAbstractTerm:
	{EvoSize}size=INT;


enum EvoVariableType returns evovar::EvoVariableType: 
	EvoIdentifier = '@ident' |
	EvoSource = '@pre' |
	EvoTarget = '@post';


EvoVariableTerm returns EvoVariableTerm:
	variable=[evovar::EvoVariable | QualifiedName](type=EvoVariableType)?;
	
	
EvoApplicationConstraintTerm returns EvoVariableTerm:
	'AC' '(' variable=[evovar::EvoMappingVariable | QualifiedName] ')';
	
	
EvoFeatureType returns EvoAbstractTerm:
	({EvoFeatureType}'featureType' ('(' variables+=EvoVariableTerm (',' variables+=EvoVariableTerm)* ')') '==' type=HyFeatureTypeEnum)
;

enum HyFeatureTypeEnum returns hyfeature::HyFeatureTypeEnum:
	OPTIONAL = 'optional' | MANDATORY = 'mandatory';


EvoGroupType returns EvoAbstractTerm:
	({EvoGroupType}'groupType' ('(' variables+=EvoGroupTerm (',' variables+=EvoGroupTerm)* ')') '==' type=HyGroupTypeEnum);


EvoGroupTerm returns EvoVariableTerm:
	variable=[evovar::EvoGroupVariable | QualifiedName](type=EvoVariableType)?;


enum HyGroupTypeEnum returns hyfeature::HyGroupTypeEnum:
	AND = 'and' | OR = 'or' | ALTERNATIVE = 'alternative';


EvoSetTerm:
	'{' variables+=EvoSetVariable (',' variables+=EvoSetVariable)* '}';


EvoSetVariable returns EvoAbstractTerm:
	EvoVariableTerm | EvoSetTerm | EvoNot;


EvoParentOf:
	'parentOf' '(' variable=EvoVariableTerm ')';


EvoSiblingsOf:
	'sibilingsOf' '(' variable=EvoVariableTerm ')';


EvoChildrenOf: 
	'childrenOf' '(' variable=

EvoEquivalence returns HyEquivalenceExpression:
	'<->';
EvoImplies returns HyImpliesExpression:
	'->';
EvoOr returns HyOrExpression:
	'||';
EvoAnd returns HyAndExpression:
	'&&';

EvoNot returns HyNotExpression:
	'!';
EvoNegation returns HyNegationExpression:
	'-';


	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyNestedExpression ::= "(" operand ")";


EvoVersionRestriction returns 
EvoFeatureReference returns HyFeatureReferenceExpression:
	feature=[feature::HyFeature] (EvoVersionRestriction)?;
	
	@SuppressWarnings(explicitSyntaxChoice)
	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyFeatureReferenceExpression ::= (feature['"', '"'] | feature[]) (versionRestriction)?;
	
	@SuppressWarnings(explicitSyntaxChoice)
	@SuppressWarnings(minOccurenceMismatch)
	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyConditionalFeatureReferenceExpression ::= "?" (feature['"', '"'] | feature[]) versionRestriction;	

	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyContextInformationReferenceExpression ::= "context:" contextInformation[];

	@SuppressWarnings(explicitSyntaxChoice)
	@SuppressWarnings(minOccurenceMismatch)
	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyAttributeReferenceExpression ::= (feature['"', '"'] | feature[]) "." attribute[];
	
	@Operator(type="primitive", weight="15", superclass="HyExpression")
	HyValueExpression ::= value;
	

EvoBooleanValue returns HyBooleanValueExpression:
	value=BOOLEAN 
;
EvoMin returns HyMinimumExpression:
	'min' '(' ')';	
EvoMax returns HyMaximumExpression:
	'max' '(' ')';
EvoIfPossible returns HyIfPossibleExpression:
	'ifPossible(' ')';
EvoLess returns HyLessExpression:
	'<';
EvoLessOrEqual returns HyLessOrEqualExpression:
	'<=';
EvoGreater returns HyGreaterExpression:
	'>';
EvoGreaterOrEqual returns HyGreaterOrEqualExpression:
	'>=';
EvoSubtraction returns HySubtractionExpression:
	'-';
EvoAddition returns HyAdditionExpression:
	'+';
EvoModulo returns HyModuloExpression:
	'%';
EvoMultiplication returns HyMultiplicationExpression:
	'*';
EvoDivision returns HyDivisionExpression:
	'/';
EvoEqual returns HyEqualExpression:
	'=';
EvoNotEqual returns HyNotEqualExpression:
	'!=';

terminal BOOLEAN:
	'true'|'false';
	HyRelativeVersionRestriction ::= "[" operator[lessThan : "<", lessThanOrEqual : "<=", equal : "=", implicitEqual : "", greaterThanOrEqual : ">=", greaterThan : ">"] version['"','"'] "]";
	HyVersionRangeRestriction ::= "[" lowerIncluded["" : "^"] lowerVersion['"','"'] "-" upperIncluded["" : "^"] upperVersion['"','"'] "]";
*/