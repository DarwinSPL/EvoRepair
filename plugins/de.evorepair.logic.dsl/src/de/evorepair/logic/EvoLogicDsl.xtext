// automatically generated by Xtext
grammar de.evorepair.logic.EvoLogicDsl with org.eclipse.xtext.common.Terminals

//generate evo_logic_dsl "http://darwinspl.de/evorepair/logic/dsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://hyvar-project.eu/feature/1.0" as dw_feature
import "http://hyvar-project.eu/feature/expression/1.0" as dw_expression
import "http://darwinspl.de/evorepair/logic/0.5" as evo_logic
import "http://darwinspl.de/evorepair/variable/0.3" as evo_variable


EvoFormula returns evo_logic::EvoFormula:	
	'formula'
	'{'
		'term' ':' term=EvoExpression ';'
	'}';


QualifiedName returns ecore::EString:
	ID ("." ID)*;


EvoExpression returns dw_expression::HyExpression:
	EvoXOr;


EvoXOr returns dw_expression::HyExpression:
	
	EvoOr({evo_logic::EvoXOrExpression.operand1=current} ('xor') operand2=EvoOr)*;
	
	
EvoOr returns dw_expression::HyExpression:
	EvoAnd({dw_expression::HyOrExpression.operand1=current} ('||') operand2=EvoAnd)*;
	
	
EvoAnd returns dw_expression::HyExpression:
	EvoEqualSize({dw_expression::HyAndExpression.operand1=current} ('&&') operand2=EvoEqualSize)*;
	
EvoEqualSize returns dw_expression::HyExpression:
	EvoEqual | EvoSize;	
	
EvoEqual returns dw_expression::HyExpression:
	EvoUnequal({dw_expression::HyEqualExpression.operand1=current} ('==') operand2=EvoUnequalSize)*;
	
	
EvoUnequalSize returns dw_expression::HyExpression:
	EvoUnequal | EvoSize;


EvoUnequal returns dw_expression::HyExpression:
	EvoImplication({dw_expression::HyNotEqualExpression.operand1=current} ('!=') operand2=EvoImplicationSize)* ;


EvoImplicationSize returns dw_expression::HyExpression:
	EvoImplication | EvoSize;


EvoImplication returns dw_expression::HyExpression:
	EvoBiconditional({dw_expression::HyImpliesExpression.operand1=current} ('=>') operand2=EvoBiconditional)*;
	
		
		
EvoBiconditional returns dw_expression::HyExpression:
	EvoSetInclusion({evo_logic::EvoBinaryExpression.operand1=current} ('<=>') operand2=EvoSetInclusion)*;
	
	
EvoSetInclusion returns dw_expression::HyExpression:
	EvoSetIntersection({evo_logic::EvoSetInclusionExpression.operand1=current} ('inclusion') operand2=EvoSetIntersection)*;
	

EvoSetIntersection returns dw_expression::HyExpression:
	EvoSetUnion({evo_logic::EvoSetIntersectionExpression.operand1=current} ('intersection') operand2=EvoSetUnion)*;


EvoSetUnion returns dw_expression::HyExpression:
	EvoSetDifference({evo_logic::EvoSetUnionExpression.operand1=current} ('union') operand2=EvoSetDifference)*;


EvoSetDifference returns dw_expression::HyExpression:
	EvoSetSymmetricDifference({evo_logic::EvoSetDifferenceExpression.operand1=current} ('difference') operand2=EvoSetSymmetricDifference)*;


EvoSetSymmetricDifference returns dw_expression::HyExpression:
	EvoSetCartesianProduct({evo_logic::EvoSetSymmetricDifferenceExpression.operand1=current} ('symmetric_difference') operand2=EvoSetCartesianProduct)*;


EvoSetCartesianProduct returns dw_expression::HyExpression:
	EvoElementOf({evo_logic::EvoSetCartesianProductExpression.operand1=current} ('x') operand2=EvoElementOf)*;


EvoSetCardinality returns dw_expression::HyExpression:
	{evo_logic::EvoSetCardinalityExpression} (('|' operand=EvoExpression '|') | ('size' '(' operand=EvoExpression ')'));


EvoElementOf returns dw_expression::HyExpression:
	EvoTerminal({evo_logic::EvoElementOfExpression.operand1=current} ('elementOf') operand2=(EvoTerminal | EvoAllMappingTerminal | EvoAllConfigurationTerminal))*;


EvoForAll returns evo_logic::EvoForAllExpression:
	'forAll' '('
		boundedVariables += EvoVariableTerm (',' boundedVariables += EvoVariableTerm)* ':'
		operand=EvoExpression
	')';
	
	
EvoExists returns evo_logic::EvoExistExpression:
	'exists' '('
		boundedVariables+=EvoVariableTerm ':'
		operand=EvoExpression
	')';


EvoNot returns dw_expression::HyNotExpression:
	('not' '(' operand=EvoExpression ')') | ('!' operand=EvoVariableTerm);


EvoTerminal returns dw_expression::HyExpression:
	EvoVariableTerm | 
	EvoSetTerm | 
	EvoForAll |
	EvoExists |
	EvoNot |
	EvoFeatureType | 
	EvoGroupType | 
	EvoSetCardinality |
	EvoChildrenOf |
	EvoParentOf |
	EvoSiblingsOf |
	'(' EvoXOr ')';
	
EvoAllMappingTerminal returns dw_expression::HyExpression:
	{evo_logic::EvoAllMappingsExpression}'All_Mappings';
	
	
EvoAllConfigurationTerminal returns dw_expression::HyExpression:
	{evo_logic::EvoAllConfigurationsExpression}'All_Configurations';


EvoSize returns dw_expression::HyExpression:
	{evo_logic::EvoSizeExpression}size=INT;


enum EvoVariableType returns evo_variable::EvoVariableType: 
	EvoNotSpecified =  "@not_specified" |
	EvoPre = '@pre' |
	EvoPost = '@post';


EvoVariableTerm returns evo_logic::EvoVariableExpression:
	variable=[evo_variable::EvoVariable | QualifiedName](type=EvoVariableType)?;
	

	
EvoFeatureType returns dw_expression::HyExpression:
	({evo_logic::EvoFeatureTypeExpression}'featureType' ('(' variables+=EvoVariableTerm (',' variables+=EvoVariableTerm)* ')') '==' type=HyFeatureTypeEnum);


enum HyFeatureTypeEnum returns dw_feature::HyFeatureTypeEnum:
	OPTIONAL = 'optional' | MANDATORY = 'mandatory';


EvoGroupType returns dw_expression::HyExpression:
	({evo_logic::EvoGroupTypeExpression}'groupType' ('(' variables+=EvoGroupTerm (',' variables+=EvoGroupTerm)* ')') '==' type=HyGroupTypeEnum);


EvoGroupTerm returns evo_logic::EvoVariableExpression:
	variable=[evo_variable::EvoGroupVariable | QualifiedName](type=EvoVariableType)?;


enum HyGroupTypeEnum returns dw_feature::HyGroupTypeEnum:
	AND = 'and' | OR = 'or' | ALTERNATIVE = 'alternative';


EvoSetTerm returns evo_logic::EvoSetExpression:
	'{' variables+=EvoSetVariable (',' variables+=EvoSetVariable)* '}';


EvoSetVariable returns dw_expression::HyExpression:
	EvoVariableTerm | EvoSetTerm | EvoNot;


EvoParentOf returns evo_logic::EvoParentOfExpression:
	'parentOf' '(' variable=EvoVariableTerm ')';


EvoSiblingsOf returns evo_logic::EvoSiblingsOfExpression:
	'sibilingsOf' '(' variable=EvoVariableTerm ')';


EvoChildrenOf returns evo_logic::EvoChildrenOfExpression: 
	'childrenOf' '(' variable=EvoVariableTerm ')';
