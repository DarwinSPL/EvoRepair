/*
 * generated by Xtext 2.12.0
 */
package de.evorepair.feature.mapping.repair.dsl.serializer;

import com.google.inject.Inject;
import de.evorepair.evolution.evovariable.EvoFeatureVariable;
import de.evorepair.evolution.evovariable.EvoVariablePackage;
import de.evorepair.feature.expression.evo_expression_dsl.Evo_expression_dslPackage;
import de.evorepair.feature.expression.evo_expression_dsl.GrammarEntry;
import de.evorepair.feature.expression.evo_expression_dsl.HyFeatureReferenceExpression;
import de.evorepair.feature.expression.serializer.EvoExpressionDslSemanticSequencer;
import de.evorepair.feature.mapping.repair.dsl.mappingRepairDsl.EvoMappingKeep;
import de.evorepair.feature.mapping.repair.dsl.mappingRepairDsl.EvoMappingReplace;
import de.evorepair.feature.mapping.repair.dsl.mappingRepairDsl.MappingRepairDslPackage;
import de.evorepair.feature.mapping.repair.dsl.mappingRepairDsl.MappingRepairGrammarEntry;
import de.evorepair.feature.mapping.repair.dsl.services.EvoMappingRepairDslGrammarAccess;
import de.evorepair.logic.evoLogicDsl.EvoAnd;
import de.evorepair.logic.evoLogicDsl.EvoBiconditional;
import de.evorepair.logic.evoLogicDsl.EvoChildrenOf;
import de.evorepair.logic.evoLogicDsl.EvoEqual;
import de.evorepair.logic.evoLogicDsl.EvoExists;
import de.evorepair.logic.evoLogicDsl.EvoFeatureType;
import de.evorepair.logic.evoLogicDsl.EvoForAll;
import de.evorepair.logic.evoLogicDsl.EvoGroupType;
import de.evorepair.logic.evoLogicDsl.EvoImplication;
import de.evorepair.logic.evoLogicDsl.EvoLogicDslPackage;
import de.evorepair.logic.evoLogicDsl.EvoNot;
import de.evorepair.logic.evoLogicDsl.EvoOr;
import de.evorepair.logic.evoLogicDsl.EvoParentOf;
import de.evorepair.logic.evoLogicDsl.EvoSatisfiable;
import de.evorepair.logic.evoLogicDsl.EvoSetCardinality;
import de.evorepair.logic.evoLogicDsl.EvoSetCartesianProduct;
import de.evorepair.logic.evoLogicDsl.EvoSetDifference;
import de.evorepair.logic.evoLogicDsl.EvoSetElementOf;
import de.evorepair.logic.evoLogicDsl.EvoSetInclusion;
import de.evorepair.logic.evoLogicDsl.EvoSetIntersection;
import de.evorepair.logic.evoLogicDsl.EvoSetSymmetricDifference;
import de.evorepair.logic.evoLogicDsl.EvoSetTerm;
import de.evorepair.logic.evoLogicDsl.EvoSetUnion;
import de.evorepair.logic.evoLogicDsl.EvoSiblingsOf;
import de.evorepair.logic.evoLogicDsl.EvoSize;
import de.evorepair.logic.evoLogicDsl.EvoUnequal;
import de.evorepair.logic.evoLogicDsl.EvoXOr;
import de.evorepair.logic.evologic.EvoFormula;
import de.evorepair.logic.evologic.EvoLogicPackage;
import de.evorepair.logic.evologic.EvoVariableTerm;
import eu.hyvar.dataValues.HyBooleanValue;
import eu.hyvar.dataValues.HyDataValuesPackage;
import eu.hyvar.dataValues.HyEnum;
import eu.hyvar.dataValues.HyEnumLiteral;
import eu.hyvar.dataValues.HyEnumValue;
import eu.hyvar.dataValues.HyNumberValue;
import eu.hyvar.feature.expression.HyAdditionExpression;
import eu.hyvar.feature.expression.HyAndExpression;
import eu.hyvar.feature.expression.HyAttributeReferenceExpression;
import eu.hyvar.feature.expression.HyBooleanValueExpression;
import eu.hyvar.feature.expression.HyConditionalFeatureReferenceExpression;
import eu.hyvar.feature.expression.HyContextInformationReferenceExpression;
import eu.hyvar.feature.expression.HyDivisionExpression;
import eu.hyvar.feature.expression.HyEqualExpression;
import eu.hyvar.feature.expression.HyEquivalenceExpression;
import eu.hyvar.feature.expression.HyExpressionPackage;
import eu.hyvar.feature.expression.HyGreaterExpression;
import eu.hyvar.feature.expression.HyGreaterOrEqualExpression;
import eu.hyvar.feature.expression.HyIfPossibleExpression;
import eu.hyvar.feature.expression.HyImpliesExpression;
import eu.hyvar.feature.expression.HyLessExpression;
import eu.hyvar.feature.expression.HyLessOrEqualExpression;
import eu.hyvar.feature.expression.HyMaximumExpression;
import eu.hyvar.feature.expression.HyMinimumExpression;
import eu.hyvar.feature.expression.HyModuloExpression;
import eu.hyvar.feature.expression.HyMultiplicationExpression;
import eu.hyvar.feature.expression.HyNegationExpression;
import eu.hyvar.feature.expression.HyNestedExpression;
import eu.hyvar.feature.expression.HyNotEqualExpression;
import eu.hyvar.feature.expression.HyNotExpression;
import eu.hyvar.feature.expression.HyOrExpression;
import eu.hyvar.feature.expression.HyRelativeVersionRestriction;
import eu.hyvar.feature.expression.HySubtractionExpression;
import eu.hyvar.feature.expression.HyValueExpression;
import eu.hyvar.feature.expression.HyVersionRangeRestriction;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class EvoMappingRepairDslSemanticSequencer extends EvoExpressionDslSemanticSequencer {

	@Inject
	private EvoMappingRepairDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HyDataValuesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HyDataValuesPackage.HY_BOOLEAN_VALUE:
				sequence_EvoMappingBooleanValue(context, (HyBooleanValue) semanticObject); 
				return; 
			case HyDataValuesPackage.HY_ENUM:
				sequence_EvoMappingEnum(context, (HyEnum) semanticObject); 
				return; 
			case HyDataValuesPackage.HY_ENUM_LITERAL:
				sequence_EvoMappingEnumLiteral(context, (HyEnumLiteral) semanticObject); 
				return; 
			case HyDataValuesPackage.HY_ENUM_VALUE:
				sequence_EvoMappingEnumValue(context, (HyEnumValue) semanticObject); 
				return; 
			case HyDataValuesPackage.HY_NUMBER_VALUE:
				sequence_EvoMappingNumberValue(context, (HyNumberValue) semanticObject); 
				return; 
			}
		else if (epackage == EvoLogicDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EvoLogicDslPackage.EVO_AND:
				sequence_EvoAnd(context, (EvoAnd) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_BICONDITIONAL:
				sequence_EvoBiconditional(context, (EvoBiconditional) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_CHILDREN_OF:
				sequence_EvoChildrenOf(context, (EvoChildrenOf) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_EQUAL:
				sequence_EvoEqual(context, (EvoEqual) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_EXISTS:
				sequence_EvoExists(context, (EvoExists) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_FEATURE_TYPE:
				sequence_EvoFeatureType(context, (EvoFeatureType) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_FOR_ALL:
				sequence_EvoForAll(context, (EvoForAll) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_GROUP_TYPE:
				sequence_EvoGroupType(context, (EvoGroupType) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_IMPLICATION:
				sequence_EvoImplication(context, (EvoImplication) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_NOT:
				sequence_EvoNot(context, (EvoNot) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_OR:
				sequence_EvoOr(context, (EvoOr) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_PARENT_OF:
				sequence_EvoParentOf(context, (EvoParentOf) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SATISFIABLE:
				sequence_EvoSatisfiable(context, (EvoSatisfiable) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_CARDINALITY:
				sequence_EvoSetCardinality(context, (EvoSetCardinality) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_CARTESIAN_PRODUCT:
				sequence_EvoSetCartesianProduct(context, (EvoSetCartesianProduct) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_DIFFERENCE:
				sequence_EvoSetDifference(context, (EvoSetDifference) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_ELEMENT_OF:
				sequence_EvoElementOf(context, (EvoSetElementOf) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_INCLUSION:
				sequence_EvoSetInclusion(context, (EvoSetInclusion) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_INTERSECTION:
				sequence_EvoSetIntersection(context, (EvoSetIntersection) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_SYMMETRIC_DIFFERENCE:
				sequence_EvoSetSymmetricDifference(context, (EvoSetSymmetricDifference) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_TERM:
				sequence_EvoSetTerm(context, (EvoSetTerm) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SET_UNION:
				sequence_EvoSetUnion(context, (EvoSetUnion) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SIBLINGS_OF:
				sequence_EvoSiblingsOf(context, (EvoSiblingsOf) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_SIZE:
				sequence_EvoSize(context, (EvoSize) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_UNEQUAL:
				sequence_EvoUnequal(context, (EvoUnequal) semanticObject); 
				return; 
			case EvoLogicDslPackage.EVO_XOR:
				sequence_EvoXOr(context, (EvoXOr) semanticObject); 
				return; 
			}
		else if (epackage == Evo_expression_dslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Evo_expression_dslPackage.GRAMMAR_ENTRY:
				sequence_GrammarEntry(context, (GrammarEntry) semanticObject); 
				return; 
			case Evo_expression_dslPackage.HY_FEATURE_REFERENCE_EXPRESSION:
				sequence_EvoMappingFeatureReferenceExpression(context, (HyFeatureReferenceExpression) semanticObject); 
				return; 
			}
		else if (epackage == EvoLogicPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EvoLogicPackage.EVO_FORMULA:
				sequence_EvoFormula(context, (EvoFormula) semanticObject); 
				return; 
			case EvoLogicPackage.EVO_VARIABLE_TERM:
				if (rule == grammarAccess.getEvoApplicationConstraintTermRule()) {
					sequence_EvoApplicationConstraintTerm(context, (EvoVariableTerm) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEvoExpressionRule()
						|| rule == grammarAccess.getEvoXOrRule()
						|| action == grammarAccess.getEvoXOrAccess().getEvoXOrOperand1Action_1_0()
						|| rule == grammarAccess.getEvoOrRule()
						|| action == grammarAccess.getEvoOrAccess().getEvoOrOperand1Action_1_0()
						|| rule == grammarAccess.getEvoAndRule()
						|| action == grammarAccess.getEvoAndAccess().getEvoAndOperand1Action_1_0()
						|| rule == grammarAccess.getEvoEqualRule()
						|| action == grammarAccess.getEvoEqualAccess().getEvoEqualOperand1Action_1_0()
						|| rule == grammarAccess.getEvoUnequalSizeRule()
						|| rule == grammarAccess.getEvoUnequalRule()
						|| action == grammarAccess.getEvoUnequalAccess().getEvoUnequalOperand1Action_1_0()
						|| rule == grammarAccess.getEvoImplicationSizeRule()
						|| rule == grammarAccess.getEvoImplicationRule()
						|| action == grammarAccess.getEvoImplicationAccess().getEvoImplicationOperand1Action_1_0()
						|| rule == grammarAccess.getEvoBiconditionalSizeRule()
						|| rule == grammarAccess.getEvoBiconditionalRule()
						|| action == grammarAccess.getEvoBiconditionalAccess().getEvoBiconditionalOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetInclusionSizeRule()
						|| rule == grammarAccess.getEvoSetInclusionRule()
						|| action == grammarAccess.getEvoSetInclusionAccess().getEvoSetInclusionOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetIntersectionRule()
						|| action == grammarAccess.getEvoSetIntersectionAccess().getEvoSetIntersectionOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetUnionRule()
						|| action == grammarAccess.getEvoSetUnionAccess().getEvoSetUnionOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetDifferenceRule()
						|| action == grammarAccess.getEvoSetDifferenceAccess().getEvoSetDifferenceOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetSymmetricDifferenceRule()
						|| action == grammarAccess.getEvoSetSymmetricDifferenceAccess().getEvoSetSymmetricDifferenceOperand1Action_1_0()
						|| rule == grammarAccess.getEvoSetCartesianProductRule()
						|| action == grammarAccess.getEvoSetCartesianProductAccess().getEvoSetCartesianProductOperand1Action_1_0()
						|| rule == grammarAccess.getEvoElementOfRule()
						|| action == grammarAccess.getEvoElementOfAccess().getEvoSetElementOfOperand1Action_1_0()
						|| rule == grammarAccess.getEvoTerminalRule()) {
					sequence_EvoApplicationConstraintTerm_EvoVariableTerm(context, (EvoVariableTerm) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEvoGroupTermRule()) {
					sequence_EvoGroupTerm(context, (EvoVariableTerm) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEvoVariableTermRule()
						|| rule == grammarAccess.getEvoSetVariableRule()) {
					sequence_EvoVariableTerm(context, (EvoVariableTerm) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == EvoVariablePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EvoVariablePackage.EVO_FEATURE_VARIABLE:
				sequence_EvoFeatureVariable(context, (EvoFeatureVariable) semanticObject); 
				return; 
			}
		else if (epackage == HyExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HyExpressionPackage.HY_ADDITION_EXPRESSION:
				sequence_EvoMappingAdditionExpression(context, (HyAdditionExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_AND_EXPRESSION:
				sequence_EvoMappingAnd(context, (HyAndExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_ATTRIBUTE_REFERENCE_EXPRESSION:
				sequence_EvoMappingAttributeReferenceExpression(context, (HyAttributeReferenceExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_BOOLEAN_VALUE_EXPRESSION:
				sequence_EvoMappingBooleanValueExpression(context, (HyBooleanValueExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_CONDITIONAL_FEATURE_REFERENCE_EXPRESSION:
				sequence_EvoMappingConditionalFeatureReferenceExpression(context, (HyConditionalFeatureReferenceExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_CONTEXT_INFORMATION_REFERENCE_EXPRESSION:
				sequence_EvoMappingContextInformationReferenceExpression(context, (HyContextInformationReferenceExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_DIVISION_EXPRESSION:
				sequence_EvoMappingDivisionExpression(context, (HyDivisionExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_EQUAL_EXPRESSION:
				sequence_EvoMappingEqual(context, (HyEqualExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_EQUIVALENCE_EXPRESSION:
				sequence_EvoMappingEquivalence(context, (HyEquivalenceExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_GREATER_EXPRESSION:
				sequence_EvoMappingGreaterExpression(context, (HyGreaterExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_GREATER_OR_EQUAL_EXPRESSION:
				sequence_EvoMappingGreaterOrEqualExpression(context, (HyGreaterOrEqualExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_IF_POSSIBLE_EXPRESSION:
				sequence_EvoMappingIfPossibleExpression(context, (HyIfPossibleExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_IMPLIES_EXPRESSION:
				sequence_EvoMappingImplication(context, (HyImpliesExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_LESS_EXPRESSION:
				sequence_EvoMappingLessExpression(context, (HyLessExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_LESS_OR_EQUAL_EXPRESSION:
				sequence_EvoMappingLessOrEqualExpression(context, (HyLessOrEqualExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_MAXIMUM_EXPRESSION:
				sequence_EvoMappingMaximumExpression(context, (HyMaximumExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_MINIMUM_EXPRESSION:
				sequence_EvoMappingMimumumExpression(context, (HyMinimumExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_MODULO_EXPRESSION:
				sequence_EvoMappingModuloExpression(context, (HyModuloExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_MULTIPLICATION_EXPRESSION:
				sequence_EvoMappingMultiplicationExpression(context, (HyMultiplicationExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_NEGATION_EXPRESSION:
				sequence_EvoMappingNegation(context, (HyNegationExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_NESTED_EXPRESSION:
				sequence_EvoMappingNestedExpression(context, (HyNestedExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_NOT_EQUAL_EXPRESSION:
				sequence_EvoMappingUnequal(context, (HyNotEqualExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_NOT_EXPRESSION:
				sequence_EvoMappingNot(context, (HyNotExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_OR_EXPRESSION:
				sequence_EvoMappingOr(context, (HyOrExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_RELATIVE_VERSION_RESTRICTION:
				sequence_EvoMappingRelativeVersionRestriction(context, (HyRelativeVersionRestriction) semanticObject); 
				return; 
			case HyExpressionPackage.HY_SUBTRACTION_EXPRESSION:
				sequence_EvoMappingSubtractionExpression(context, (HySubtractionExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_VALUE_EXPRESSION:
				sequence_EvoMappingValueExpression(context, (HyValueExpression) semanticObject); 
				return; 
			case HyExpressionPackage.HY_VERSION_RANGE_RESTRICTION:
				sequence_EvoMappingVersionRangeRestriction(context, (HyVersionRangeRestriction) semanticObject); 
				return; 
			}
		else if (epackage == MappingRepairDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MappingRepairDslPackage.EVO_MAPPING_KEEP:
				sequence_EvoMappingKeep(context, (EvoMappingKeep) semanticObject); 
				return; 
			case MappingRepairDslPackage.EVO_MAPPING_REPLACE:
				sequence_EvoMappingReplace(context, (EvoMappingReplace) semanticObject); 
				return; 
			case MappingRepairDslPackage.MAPPING_REPAIR_GRAMMAR_ENTRY:
				sequence_MappingRepairGrammarEntry(context, (MappingRepairGrammarEntry) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     EvoMappingRepairExpression returns EvoMappingKeep
	 *     EvoMappingKeep returns EvoMappingKeep
	 *
	 * Constraint:
	 *     operand=EvoMappingExpression
	 */
	protected void sequence_EvoMappingKeep(ISerializationContext context, EvoMappingKeep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_KEEP__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_KEEP__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEvoMappingKeepAccess().getOperandEvoMappingExpressionParserRuleCall_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EvoMappingRepairExpression returns EvoMappingReplace
	 *     EvoMappingReplace returns EvoMappingReplace
	 *
	 * Constraint:
	 *     (operand1=EvoMappingExpression operand2=EvoMappingExpression)
	 */
	protected void sequence_EvoMappingReplace(ISerializationContext context, EvoMappingReplace semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_REPLACE__OPERAND1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_REPLACE__OPERAND1));
			if (transientValues.isValueTransient(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_REPLACE__OPERAND2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingRepairDslPackage.Literals.EVO_MAPPING_REPLACE__OPERAND2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEvoMappingReplaceAccess().getOperand1EvoMappingExpressionParserRuleCall_2_0(), semanticObject.getOperand1());
		feeder.accept(grammarAccess.getEvoMappingReplaceAccess().getOperand2EvoMappingExpressionParserRuleCall_6_0(), semanticObject.getOperand2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingRepairGrammarEntry returns MappingRepairGrammarEntry
	 *
	 * Constraint:
	 *     action=EvoMappingRepairExpression
	 */
	protected void sequence_MappingRepairGrammarEntry(ISerializationContext context, MappingRepairGrammarEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingRepairDslPackage.Literals.MAPPING_REPAIR_GRAMMAR_ENTRY__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingRepairDslPackage.Literals.MAPPING_REPAIR_GRAMMAR_ENTRY__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingRepairGrammarEntryAccess().getActionEvoMappingRepairExpressionParserRuleCall_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
}
